//----------------------------------------------------------------------------------------
//  This file is enum class of atom types and molecular types.
//    generated by ./convert_model_indicator.py
//----------------------------------------------------------------------------------------
#pragma once

#include <cstdint>
#include <string>
#include <tuple>
#include <stdexcept>


enum class MolName : uint_fast32_t {
    AA_Ar,
    AA_wat,
};

enum class AtomName : uint_fast32_t {
    Ar,
    Ow,
    Hw,
};

namespace ENUM {

    //--- basic interface for "MolType"
    inline std::string whatis(const MolName &e){
        switch (e) {
            case MolName::AA_Ar:
                return "AA_Ar";
            break;

            case MolName::AA_wat:
                return "AA_wat";
            break;

            default:
                throw std::out_of_range("undefined enum value in MolName");
        }
    }

    inline MolName which_MolName(const std::string &str){
        if(str == "AA_Ar"){
            return MolName::AA_Ar;
        }
        else if(str == "AA_wat"){
            return MolName::AA_wat;
        }
        else {
            std::cerr << "  MolName: input = " << str << std::endl;
            throw std::out_of_range("undefined enum value in MolName");
        }
    }

    inline size_t size_MolName(){
        return 2;
    }

    //--- basic interface for "AtomType"
    inline std::string whatis(const AtomName &e){
        switch (e) {
            case AtomName::Ar:
                return "Ar";
            break;

            case AtomName::Ow:
                return "Ow";
            break;

            case AtomName::Hw:
                return "Hw";
            break;

            default:
                throw std::out_of_range("undefined enum value in AtomName");
        }
    }

    inline AtomName which_AtomName(const std::string &str){
        if(str == "Ar"){
            return AtomName::Ar;
        }
        else if(str == "Ow"){
            return AtomName::Ow;
        }
        else if(str == "Hw"){
            return AtomName::Hw;
        }
        else {
            std::cerr << "  AtomName: input = " << str << std::endl;
            throw std::out_of_range("undefined enum value in AtomName");
        }
    }

    inline size_t size_AtomName(){
        return 3;
    }

    //--- convert std::tuple<...> to std::string
    template<typename T>
    std::string whatis_string_Impl(T const &v){
        return std::to_string(v);
    }

    inline std::string whatis_string_Impl(MolName const &e){
        return whatis(e);
    }

    inline std::string whatis_string_Impl(AtomName const &e){
        return whatis(e);
    }

    template<typename Tuple, size_t Index = std::tuple_size<Tuple>::value-1>
    struct whatis_Impl{
        static void apply(std::string &str, Tuple const &tuple){
            whatis_Impl<Tuple, Index-1>::apply(str, tuple);
            str += ", " + whatis_string_Impl(std::get<Index>(tuple));
        }
    };

    template<typename Tuple>
    struct whatis_Impl<Tuple, 0>{
        static void apply(std::string &str, Tuple const &tuple){
            str = whatis_string_Impl(std::get<0>(tuple));
        }
    };

    template<typename Tuple>
    inline std::string whatis(Tuple const &tt){
        std::string str{};
        whatis_Impl<Tuple>::apply(str, tt);
        return "(" + str + ")";
    }

}

//--- output function as "std::cout << (enum class::value)"
inline std::ostream& operator << (std::ostream& s, const MolName &e){
    s << ENUM::whatis(e);
    return s;
}

inline std::ostream& operator << (std::ostream& s, const AtomName &e){
    s << ENUM::whatis(e);
    return s;
}


